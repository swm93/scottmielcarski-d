import { Component, Input, Output } from '@angular/core';



@Component({
  selector: 'swm-background-text',
  template: '{{ text }}',
  styleUrls: ['./background-text.component.scss'],
  host: {
    '[style.color]': 'color',
    '[style.opacity]': 'opacity'
  }
})
export class BackgroundTextComponent {
  @Input()
  public color: string = "#000000";

  @Input()
  public opacity: number = 0.05;

  @Input()
  public text: string = 'Renderer::Renderer(GameState* gamestate, GLFWwindow* window) { GLuint vao_id; glGenVertexArrays(1, &vao_id); glBindVertexArray(vao_id); LOG(Debug::getGLErrors()); GLuint vbo_id; glGenBuffers(1, &vbo_id); glBindBuffer(GL_ARRAY_BUFFER, vbo_id); LOG(Debug::getGLErrors()); this->_gamestate = gamestate; this->_window = window; } void Renderer::beginDraw(double t, double dt) { static Vi2 framebuffer_size = {}; static Vi2 window_size = {}; static Vf2 world_pos = {}; static float world_zoom = 0.f; Vi2 new_window_size = this->_gamestate->window_size; Vf2 new_world_pos = this->_gamestate->worldPosition(); float new_world_zoom = this->_gamestate->world_zoom; // update the projection matricies if the window size changed if (window_size != new_window_size) { window_size = new_window_size; glfwGetFramebufferSize(this->_window, &framebuffer_size.x, &framebuffer_size.y); Vi2 window_size_m = window_size / PIXELS_PER_METER; this->_proj_mat_m = M4x4<float>::orthographicProj( 0.f, window_size_m.x, 0.f, window_size_m.y, -1.f, 1.f ); this->_proj_mat_px = M4x4<float>::orthographicProj( 0.f, window_size.x, 0.f, window_size.y, -1.f, 1.f ); } // update the view matrix if the world pos/zoom changed if (world_pos != new_world_pos || world_zoom != new_world_zoom) { world_pos = new_world_pos; world_zoom = new_world_zoom; this->_view_mat = M4x4<float>::translate(-world_pos.x, -world_pos.y, 0.f) * M4x4<float>::scale(world_zoom); } glViewport( 0, 0, framebuffer_size.x, framebuffer_size.y ); glClear(GL_COLOR_BUFFER_BIT); // TODO(scott): this should be based on the render element glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glEnable(GL_BLEND); LOG(Debug::getGLErrors()); } void Renderer::endDraw() { glDisable(GL_BLEND); glfwSwapBuffers(this->_window); glfwPollEvents(); LOG(Debug::getGLErrors()); } void Renderer::draw(const RenderGroup& group, Vf2 offset) { Vf2 total_offset = offset + group.offset; for (const RenderElement& el : group.render_elements) { this->draw(el, total_offset); } for (const RenderGroup& g : group.render_groups) { this->draw(g, total_offset); } } void Renderer::draw(const RenderElement& el, Vf2 position) { glBufferData(GL_ARRAY_BUFFER, sizeof(float) * el.verticies.data.size(), &el.verticies.data[0], GL_STATIC_DRAW); LOG(Debug::getGLErrors()); for (int i=0; i<el.verticies.num_components; ++i) { glEnableVertexAttribArray(i); LOG(Debug::getGLErrors()); glVertexAttribPointer( i, el.verticies.packing[i].size, GL_FLOAT, GL_FALSE, el.verticies.stride, el.verticies.packing[i].offset ); LOG(Debug::getGLErrors()); } M4x4<float> view_mat; M4x4<float> proj_mat; M4x4<float> model_mat = M4x4<float>::translate(position.x + el.offset.x, position.y + el.offset.y, 0.f); M4x4<float> mat; switch (el.layer) { case RenderElement::Layer::Game: view_mat = this->_view_mat; proj_mat = this->_proj_mat_m; break; case RenderElement::Layer::HUD: view_mat = M4x4<float>::identity(); proj_mat = this->_proj_mat_px; break; default: view_mat = M4x4<float>::identity(); proj_mat = M4x4<float>::identity(); break; } glUseProgram(el.program->id); LOG(Debug::getGLErrors()); if (el.texture.identifier != 0) { glActiveTexture(GL_TEXTURE0); // TODO(scott): have some sort of lasted used replacement for binding textures glBindTexture(GL_TEXTURE_2D, el.texture.identifier); } glUniformMatrix4fv( el.program->uniforms["view_mat"], 1, GL_FALSE, &view_mat[0][0] ); LOG(Debug::getGLErrors()); glUniformMatrix4fv( el.program->uniforms["projection_mat"], 1, GL_FALSE, &proj_mat[0][0] ); LOG(Debug::getGLErrors()); glUniformMatrix4fv( el.program->uniforms["model_mat"], 1, GL_FALSE, &model_mat[0][0] ); LOG(Debug::getGLErrors()); switch (el.program->type) { case Program::ProgramType::Entity: glVertexAttrib2f( el.program->attributes["texture_size_px"], 64, 64 ); LOG(Debug::getGLErrors()); glVertexAttrib2f( el.program->attributes["sprite_size_px"], 64, 64 ); LOG(Debug::getGLErrors()); glVertexAttrib2f( el.program->attributes["sprite_offset_px"], 0.f, 0.f ); LOG(Debug::getGLErrors()); break; default: break; } glDrawArrays(el.verticies.draw_mode, 0, el.verticies.num_verticies); LOG(Debug::getGLErrors()); for (int i=0; i<el.verticies.num_components; ++i) { glDisableVertexAttribArray(i); LOG(Debug::getGLErrors()); } if (el.texture.identifier != 0) { glBindTexture(GL_TEXTURE_2D, 0); } } //*/ void Renderer::draw(std::string text, Font* font, Vf2 position) { Program* program = ProgramFactory::get("font"); RGBA color = {1.f, 1.f, 1.f, 1.f}; Vf2 current_position = position; for (const char& c : text) { // TODO(scott): support other modifiers if (c == "\n") { current_position.x = position.x; current_position.y -= font->y_advance; continue; } glBindTexture(GL_TEXTURE_2D, font->texture_id); if (c >= font->char_range_offset && c < font->char_range_offset + font->char_range_length) { Glyph glyph = font->glyphs[c - font->char_range_offset]; VertexData::Verticies verticies = {}; VertexData::rect( verticies, { glyph.offset.x0 + current_position.x, glyph.offset.y0 + current_position.y }, { glyph.offset.x1 + current_position.x, glyph.offset.y0 + current_position.y }, { glyph.offset.x0 + current_position.x, glyph.offset.y1 + current_position.y }, { glyph.offset.x1 + current_position.x, glyph.offset.y1 + current_position.y } ); VertexData::uv( verticies, { glyph.uv_coords.s0, glyph.uv_coords.t1 }, { glyph.uv_coords.s1, glyph.uv_coords.t1 }, { glyph.uv_coords.s0, glyph.uv_coords.t0 }, { glyph.uv_coords.s1, glyph.uv_coords.t0 } ); VertexData::color(verticies, color); RenderElement el = { program, verticies, RenderElement::Layer::HUD, {0.f, 0.f}, static_cast<GLint>(font->texture_id) }; this->draw(el, { 0.f, 0.f }); current_position.x += glyph.advance_x; } } } void Renderer::draw(char* text, int length, Font* font, Vf2 position) { Program* program = ProgramFactory::get("font"); RGBA color = {1.f, 1.f, 1.f, 1.f}; Vf2 current_position = position; for (int i = 0; i < length; i++) { char c = text[i]; // TODO(scott): support other modifiers if (c == "\n") { current_position.x = position.x; current_position.y -= font->y_advance; continue; } glBindTexture(GL_TEXTURE_2D, font->texture_id); if (c >= font->char_range_offset && c < font->char_range_offset + font->char_range_length) { Glyph glyph = font->glyphs[c - font->char_range_offset]; VertexData::Verticies verticies = {}; VertexData::rect( verticies, { glyph.offset.x0 + current_position.x, glyph.offset.y0 + current_position.y }, { glyph.offset.x1 + current_position.x, glyph.offset.y0 + current_position.y }, { glyph.offset.x0 + current_position.x, glyph.offset.y1 + current_position.y }, { glyph.offset.x1 + current_position.x, glyph.offset.y1 + current_position.y } ); VertexData::uv( verticies, { glyph.uv_coords.s0, glyph.uv_coords.t1 }, { glyph.uv_coords.s1, glyph.uv_coords.t1 }, { glyph.uv_coords.s0, glyph.uv_coords.t0 }, { glyph.uv_coords.s1, glyph.uv_coords.t0 } ); VertexData::color(verticies, color); RenderElement el = { program, verticies, RenderElement::Layer::HUD, {0.f, 0.f}, static_cast<GLint>(font->texture_id) }; this->draw(el, { 0.f, 0.f }); current_position.x += glyph.advance_x; } } }';
}
